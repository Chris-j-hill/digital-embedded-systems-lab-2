C51 COMPILER V9.54   MEASUREMENT                                                           02/25/2018 01:10:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MEASUREMENT
OBJECT MODULE PLACED IN .\Objects\measurement.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\measurement.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\measurement.lst) TABS(2) OBJECT(.\Objects\measurement.obj)

line level    source

   1          
   2          #include "measurement.h"
   3          #include <ADUC841.H>
   4          #include "config.h"
   5          
   6          extern volatile uint8 mode;
   7          
   8          // misc variables
   9          #ifdef USE_CIRCULAR_BUFFER
  10          #define BUFSIZE 16
  11          volatile uint16 circular_buffer[BUFSIZE] ={0}; // array to hold values
  12          #else
              volatile uint16 block_buffer =0;                // simple value to store sum
              #define DC_AVG_NUM_SAMPLES BUFSIZE*4            // can afford to take more samples if block averaging
              
              #endif
  17          uint8 buff_index_counter =0;    //indexing variable for doing running sums/filtering
  18          
  19          
  20          
  21          
  22          //dc averaging variables
  23          #define DC_TIMER_OVERFLOWS 10   // n*5.9 milliseconds between readings
  24          uint8 dc_voltage_num_timer_overflows =0; //counter for the number of timer overflows
  25          uint16 dc_sum;
  26          volatile uint16 dc_avg;   // value to be displayed, stored as 12bit number, convert to volts before display
  27          
  28          
  29          // rms measurement variables
  30          
  31          #define RMS_TIMER_OVERFLOWS 5   // n*5.9 milliseconds between readings
  32          #define RMS_MEASUREMENT_NUM_SAMPLES 128   //number of samples taken before reporting result
  33          uint8 rms_measurement_num_timer_overflows = 0;
  34          uint32 rms_sum;   //sum needs to be 32bit since sum is of squared readings
  35          volatile uint16 rms_avg;
  36          
  37          //p2p measurement variables
  38          
  39          volatile uint16 p2p_value;
  40          
  41          
  42          
  43          //freq measurement variables
  44          extern volatile uint32 avg_freq;
  45          extern volatile uint8 nb_overflow;
  46          
  47          
  48          
  49          
  50          void setup_timers_dc_averaging(){
  51   1          
  52   1          T2CON = 7;  // all zero except run control
  53   1          ET2   = 1;     // enable timer 2 interrupt
  54   1          EA = 1;
C51 COMPILER V9.54   MEASUREMENT                                                           02/25/2018 01:10:39 PAGE 2   

  55   1        
  56   1        //disable other timers...
  57   1      
  58   1      }
  59            
  60          void setup_timers_rms_measurment(){   //same as dc averaging...
  61   1          T2CON = 7;  // all zero except run control
  62   1          ET2   = 1;     // enable timer 2 interrupt
  63   1          EA = 1;
  64   1      } 
  65          
  66          void setup_timers_freq_period_counting() {
  67   1          // Set up timer 2 in timer mode (bit1), capture mode(bit0), external control activated(bit3), timer run(
             -bit2), serial not needed(bit4-5),then interrupt modified by hardware
  68   1          //T2CON = 0b00001101;  // all zero except run control
  69   1          T2CON = 13;  // all zero except run control
  70   1          ET2   = 1;     // enable timer 2 interrupt
  71   1          EA = 1;       // enable general interrupt
  72   1        
  73   1          //uint8 nb_t2_of =0;
  74   1        
  75   1        
  76   1        //disable other timers...
  77   1        
  78   1      }
  79          
  80          
  81          
  82          
  83          
  84          
  85          void dc_voltage_measurment(){ // functions to store measurements as required
  86   1      
  87   1        if (TF2 == 1){  //if counter overflow, increment counter
  88   2        dc_voltage_num_timer_overflows = (dc_voltage_num_timer_overflows+1) % DC_TIMER_OVERFLOWS;
  89   2        TF2 = 0;
  90   2      
  91   2          if(dc_voltage_num_timer_overflows ==0){ 
  92   3            
  93   3            uint16 val = read_analog_input_pin();
  94   3            
  95   3          #ifdef USE_CIRCULAR_BUFFER    // will update avg every time a value is read
  96   3            
  97   3            //circular buffer implementation
  98   3            
  99   3            buff_index_counter = (buff_index_counter + 1) % BUFSIZE;
 100   3            dc_sum = dc_sum - circular_buffer[buff_index_counter];        //subtract the old value from the running sum
 101   3            circular_buffer[buff_index_counter] = val;
 102   3            dc_sum = dc_sum + circular_buffer[buff_index_counter];        //add new value to sum
 103   3            dc_avg = dc_sum/BUFSIZE;
 104   3            
 105   3            
 106   3            
 107   3          #else                         // update avg every after DC_AVG_NUM_SAMPLES readings
                    
                    //block buffer implementation 
                    
                    buff_index_counter = (buff_index_counter + 1) % DC_AVG_NUM_SAMPLES;
                    if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, reset sum
                      dc_avg= dc_sum/DC_AVG_NUM_SAMPLES;  //calculate avg
                      dc_sum=0; //reset_sum   
                    }
C51 COMPILER V9.54   MEASUREMENT                                                           02/25/2018 01:10:39 PAGE 3   

                    dc_sum = dc_sum+val;
                    
                  #endif
 119   3            
 120   3          }
 121   2        }
 122   1        
 123   1        else if(EXF2==1)    //if for some reason this triggered interrupt, reset to stop continual interrupts
 124   1          EXF2 =0;
 125   1      } 
 126          
 127          void rms_measurment(){
 128   1      
 129   1        if (TF2 == 1){  //if counter overflow, increment counter
 130   2          rms_measurement_num_timer_overflows = (rms_measurement_num_timer_overflows+1) % RMS_TIMER_OVERFLOWS;
 131   2          TF2 = 0;
 132   2      
 133   2            if(rms_measurement_num_timer_overflows ==0){  
 134   3              
 135   3              uint16 val = read_analog_input_pin();
 136   3              
 137   3              buff_index_counter = (buff_index_counter + 1) % RMS_MEASUREMENT_NUM_SAMPLES;
 138   3              if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, reset sum
 139   4                rms_avg = my_sqrt((rms_sum/RMS_MEASUREMENT_NUM_SAMPLES)); //calculate avg
 140   4                rms_sum=0;  //reset_sum   
 141   4              }
 142   3              rms_sum = rms_sum+(val*val);    //running sum of squared readings
 143   3              
 144   3            }
 145   2          }
 146   1      
 147   1        else if(EXF2==1)    //if for some reason this triggered interrupt, reset to stop continual interrupts
 148   1          EXF2 =0;
 149   1      
 150   1      }         
 151          
 152          void p2p_measurement(){}      
 153          
 154          void frequency_measurement() {
 155   1        //Setup the initial values of the static variables to ZERO
 156   1        static uint32 new_sample=0;
 157   1        static uint8 past_RCAP2H=0;
 158   1        static uint8 past_RCAP2L=0;
 159   1        
 160   1        
 161   1        if(EXF2==1){ // new edges incoming (of the periodic signal we want to measure) => end of the a period
 162   2          //What is the new sample ?
 163   2          new_sample = (nb_overflow<<16)  + ((RCAP2H-past_RCAP2H)<<8) + (RCAP2L-past_RCAP2L); //concatenate the 3 b
             -ytes
 164   2          //Update the average using IIR filter
 165   2          avg_freq=(new_sample*3)/20 + (avg_freq*17)/20;   //alpha chosen 0.15=3/20
 166   2          
 167   2          //Prepare the next interruption
 168   2          past_RCAP2H=RCAP2H;
 169   2          past_RCAP2L=RCAP2L;
 170   2          nb_overflow=0;
 171   2          EXF2=0;//clear the flag
 172   2        }
 173   1          else  //EXF2==0 and TF2==1
 174   1        {
 175   2            nb_overflow++;
 176   2            TF2=0; //clear the flag
C51 COMPILER V9.54   MEASUREMENT                                                           02/25/2018 01:10:39 PAGE 4   

 177   2        } 
 178   1        
 179   1      }
 180            
 181          uint16 read_analog_input_pin(){
 182   1      //CS0 = 0;  //confirm analog pin
 183   1      //CS1 = 1;
 184   1      //CS2 = 0;
 185   1      //CS3 = 0;
 186   1      uint8 val_LSB = ADCDATAL;
 187   1      uint8 val_MSB = ADCDATAH;
 188   1      uint16 val = (val_MSB>>8)+val_LSB;
 189   1        return val;
 190   1      } 
 191          
 192          
 193          /*------------------------------------------------
 194          Interrupt service routine for timer 2 interrupt.
 195          Called by the hardware when the interrupt occurs.
 196          ------------------------------------------------*/
 197          void timer2 (void) interrupt 5   // interrupt vector at 002BH
 198          {
 199   1        switch(mode){
 200   2          case 0:   dc_voltage_measurment();  break;
 201   2          case 1:   rms_measurment();         break;
 202   2          case 2:   p2p_measurement();        break;
 203   2          case 3:   frequency_measurement();  break;
 204   2        }   
 205   1        
 206   1      } // end timer2 interrupt service routine
 207          
 208          uint8 analog_reading_to_voltage(uint16 value){
 209   1        return ((value*VOLTAGE_RANGE)/4096);
 210   1      }
 211          
 212          uint8 my_sqrt(uint16 squared_val){
 213   1        
 214   1        /* method:
 215   1        sum odd numbers up to squared_val
 216   1        number of values used in sum is root
 217   1        
 218   1        1+3 = 4         -> 2 values in sum, 2 is root of 4
 219   1        1+3+5 = 9       -> 3 is root 9
 220   1        1+3+5+7 = 16    -> 4 is root 16
 221   1        1+3+5+7+9 = 25  -> 5 is root 25
 222   1        ...
 223   1        
 224   1        this method should be fast since no multiplication required
 225   1        Note: will return the root rounded up to nearest value 
 226   1        -> my_sqrt(2), my_sqrt(3), my_sqrt(4) will all return 2
 227   1        
 228   1        */
 229   1        
 230   1        uint8 i;    //odd numbers to be added to sum
 231   1        uint16 x=0;   //running total
 232   1        uint8 count=0;
 233   1        for(i=1;x<=squared_val;i+=2)
 234   1              {
 235   2                  x = x + i;
 236   2                  count++;
 237   2      
 238   2              }
C51 COMPILER V9.54   MEASUREMENT                                                           02/25/2018 01:10:39 PAGE 5   

 239   1        return count;
 240   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    490    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
