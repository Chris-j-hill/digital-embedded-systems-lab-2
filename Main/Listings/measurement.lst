C51 COMPILER V9.54   MEASUREMENT                                                           02/26/2018 23:00:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MEASUREMENT
OBJECT MODULE PLACED IN .\Objects\measurement.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\measurement.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\measurement.lst) TABS(2) OBJECT(.\Objects\measurement.obj)

line level    source

   1          
   2          #include "measurement.h"
   3          #include <ADUC841.H>
   4          #include "config.h"
   5          
   6          extern volatile uint8 mode;
   7          
   8          // misc variables
   9          #ifdef USE_CIRCULAR_BUFFER
  10          #define BUFSIZE 16
  11          volatile uint16 circular_buffer[BUFSIZE] ={0}; // array to hold values
  12          #else
              volatile uint16 block_buffer =0;                // simple value to store sum
              #define DC_AVG_NUM_SAMPLES BUFSIZE*4            // can afford to take more samples if block averaging
              
              #endif
  17          uint8 buff_index_counter =0;    //indexing variable for doing running sums/filtering
  18          
  19          
  20          
  21          
  22          //dc averaging variables
  23          #define DC_TIMER_OVERFLOWS 8    // n*5.9 milliseconds between readings. NOTE: must be a power of 2
  24          #define DC_TIMER_INCREMENT 256/DC_TIMER_OVERFLOWS
  25          uint16 dc_sum;
  26          volatile uint16 dc_avg;   // value to be displayed, stored as 12bit number, convert to volts before display
  27          
  28          
  29          // rms measurement variables
  30          #define RMS_TIMER_OVERFLOWS 8   // n*5.9 milliseconds between readings. NOTE: must be a power of 2
  31          #define RMS_TIMER_INCREMENT 256/RMS_TIMER_OVERFLOWS
  32          #define RMS_MEASUREMENT_NUM_SAMPLES 128   //number of samples taken before reporting result
  33          uint32 rms_sum;   //sum needs to be 32bit since sum is of squared readings
  34          volatile uint16 rms_avg;
  35          
  36          //p2p measurement variables
  37          
  38          volatile uint16 p2p_value;
  39          
  40          
  41          
  42          //freq measurement variables
  43          extern volatile uint32 avg_freq;
  44          extern volatile uint8 nb_overflow;
  45          
  46          
  47          
  48          
  49          void setup_timers_dc_averaging(){
  50   1          
  51   1          T2CON = 7;  // all zero except run control
  52   1          ET2   = 1;     // enable timer 2 interrupt
  53   1          EA = 1;
  54   1        
C51 COMPILER V9.54   MEASUREMENT                                                           02/26/2018 23:00:40 PAGE 2   

  55   1        //disable other timers...
  56   1      
  57   1      }
  58            
  59          void setup_timers_rms_measurment(){   //same as dc averaging...
  60   1          T2CON = 7;  // all zero except run control
  61   1          ET2   = 1;     // enable timer 2 interrupt
  62   1          EA = 1;
  63   1      } 
  64          
  65          void setup_timers_freq_period_counting() {
  66   1          // Set up timer 2 in timer mode (bit1), capture mode(bit0), external control activated(bit3), timer run(
             -bit2), serial not needed(bit4-5),then interrupt modified by hardware
  67   1      //    T2CON = #00001101b;  // all zero except run control
  68   1          T2CON = 13;  // all zero except run control
  69   1          ET2   = 1;     // enable timer 2 interrupt
  70   1          EA = 1;       // enable general interrupt
  71   1        
  72   1          //uint8 nb_t2_of =0;
  73   1        
  74   1        
  75   1        //disable other timers...
  76   1        
  77   1      }
  78          
  79          
  80          
  81          
  82          
  83          
  84          void dc_voltage_measurment(){ // functions to store measurements as required
  85   1        
  86   1        static uint8 dc_voltage_num_timer_overflows=0; //counter for the number of timer overflows
  87   1        
  88   1        if (TF2 == 1){  //if counter overflow, increment counter
  89   2          // todo make the overflow happen in hardware
  90   2        dc_voltage_num_timer_overflows = dc_voltage_num_timer_overflows+DC_TIMER_INCREMENT;  // increment chosen 
             -to cause hardware overflow
  91   2        TF2 = 0;
  92   2      
  93   2          if(dc_voltage_num_timer_overflows ==0){ 
  94   3            
  95   3            uint16 val = read_analog_input_pin();
  96   3            
  97   3          #ifdef USE_CIRCULAR_BUFFER    // will update avg every time a value is read
  98   3            
  99   3            //circular buffer implementation
 100   3            
 101   3            buff_index_counter = (buff_index_counter + 1) % BUFSIZE;
 102   3            dc_sum = dc_sum - circular_buffer[buff_index_counter];        //subtract the old value from the running sum
 103   3            circular_buffer[buff_index_counter] = val;
 104   3            dc_sum = dc_sum + circular_buffer[buff_index_counter];        //add new value to sum
 105   3            dc_avg = dc_sum/BUFSIZE;
 106   3            
 107   3            
 108   3            
 109   3          #else                         // update avg every after DC_AVG_NUM_SAMPLES readings
                    
                    //block buffer implementation 
                    
                    buff_index_counter = (buff_index_counter + 1) % DC_AVG_NUM_SAMPLES;
                    dc_sum = dc_sum+val;
C51 COMPILER V9.54   MEASUREMENT                                                           02/26/2018 23:00:40 PAGE 3   

                    if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, calcualte avg and reset sum
                      dc_avg= dc_sum/DC_AVG_NUM_SAMPLES;
                      dc_sum=0; 
                    }
              
                    
                  #endif
 122   3            
 123   3          }
 124   2        }
 125   1        
 126   1        else if(EXF2==1)    //if the pin input triggered interrupt, reset
 127   1          EXF2 =0;
 128   1      } 
 129          
 130          void rms_measurment(){
 131   1      
 132   1        static uint8 rms_measurement_num_timer_overflows=0;
 133   1        
 134   1        if (TF2 == 1){  //if counter overflow, increment counter
 135   2          
 136   2          rms_measurement_num_timer_overflows = rms_measurement_num_timer_overflows+RMS_TIMER_INCREMENT;
 137   2          
 138   2          TF2 = 0;
 139   2      
 140   2            if(rms_measurement_num_timer_overflows ==0){  
 141   3              
 142   3              uint16 val = read_analog_input_pin();
 143   3              
 144   3              buff_index_counter = (buff_index_counter + 1) % RMS_MEASUREMENT_NUM_SAMPLES;
 145   3              rms_sum = rms_sum+(val*val);    //running sum of squared readings
 146   3              
 147   3              if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, calculate rms and reset sum
 148   4                rms_avg = my_sqrt((rms_sum/RMS_MEASUREMENT_NUM_SAMPLES));
 149   4                rms_sum=0;
 150   4              }
 151   3            }
 152   2          }
 153   1      
 154   1        else if(EXF2==1)    
 155   1          EXF2 =0;
 156   1      }         
 157          
 158          void p2p_measurement(){}      
 159          
 160          void frequency_measurement() {
 161   1        //Setup the initial values of the static variables to ZERO
 162   1        static uint32 new_sample=0;
 163   1        static uint8 past_RCAP2H=0;
 164   1        static uint8 past_RCAP2L=0;
 165   1        
 166   1        
 167   1        if(EXF2==1){ // new edges incoming (of the periodic signal we want to measure) => end of the a period
 168   2          //What is the new sample ?
 169   2          new_sample = (nb_overflow<<16)  + ((RCAP2H-past_RCAP2H)<<8) + (RCAP2L-past_RCAP2L); //concatenate the 3 b
             -ytes
 170   2          //Update the average using IIR filter
 171   2          avg_freq=(new_sample*3)/20 + (avg_freq*17)/20;   //alpha chosen 0.15=3/20
 172   2          
 173   2          //Prepare the next interruption
 174   2          past_RCAP2H=RCAP2H;
 175   2          past_RCAP2L=RCAP2L;
C51 COMPILER V9.54   MEASUREMENT                                                           02/26/2018 23:00:40 PAGE 4   

 176   2          nb_overflow=0;
 177   2          EXF2=0;//clear the flag
 178   2        }
 179   1          else  //EXF2==0 and TF2==1
 180   1        {
 181   2            nb_overflow++;
 182   2            TF2=0; //clear the flag
 183   2        } 
 184   1        
 185   1      }
 186            
 187          uint16 read_analog_input_pin(){
 188   1      //CS0 = 0;  //confirm analog pin
 189   1      //CS1 = 1;
 190   1      //CS2 = 0;
 191   1      //CS3 = 0;
 192   1      uint8 val_LSB = ADCDATAL;
 193   1      uint8 val_MSB = ADCDATAH;
 194   1      uint16 val = (val_MSB>>8)+val_LSB;
 195   1        return val;
 196   1      } 
 197          
 198          
 199          /*------------------------------------------------
 200          Interrupt service routine for timer 2 interrupt.
 201          Called by the hardware when the interrupt occurs.
 202          ------------------------------------------------*/
 203          void timer2 (void) interrupt 5   // interrupt vector at 002BH
 204          {
 205   1        // time effiency requires bitwise operation with if/else statements
 206   1        switch(mode){
 207   2          case 0:   dc_voltage_measurment();  break;
 208   2          case 1:   rms_measurment();         break;
 209   2          case 2:   p2p_measurement();        break;
 210   2          case 3:   frequency_measurement();  break;
 211   2        }   
 212   1        
 213   1      } // end timer2 interrupt service routine
 214          
 215          uint8 analog_reading_to_voltage(uint16 value){
 216   1        return ((value*VOLTAGE_RANGE)/4096);
 217   1      }
 218          
 219          uint8 my_sqrt(uint16 squared_val){
 220   1        
 221   1        /* method:
 222   1        sum odd numbers up to squared_val
 223   1        number of values used in sum is root
 224   1        
 225   1        1+3 = 4         -> 2 values in sum, 2 is root of 4
 226   1        1+3+5 = 9       -> 3 is root 9
 227   1        1+3+5+7 = 16    -> 4 is root 16
 228   1        1+3+5+7+9 = 25  -> 5 is root 25
 229   1        ...
 230   1        
 231   1        this method should be fast since no multiplication required
 232   1        Note: will return the root rounded up to nearest value 
 233   1        -> my_sqrt(2), my_sqrt(3), my_sqrt(4) will all return 2
 234   1        
 235   1        */
 236   1        
 237   1        uint8 i;    //odd numbers to be added to sum
C51 COMPILER V9.54   MEASUREMENT                                                           02/26/2018 23:00:40 PAGE 5   

 238   1        uint16 x=0;   //running total
 239   1        uint8 count=0;
 240   1        for(i=1;x<=squared_val;i+=2)
 241   1              {
 242   2                  x = x + i;
 243   2                  count++;
 244   2      
 245   2              }
 246   1        return count;
 247   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    462    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
