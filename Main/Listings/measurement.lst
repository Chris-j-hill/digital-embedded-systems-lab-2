C51 COMPILER V9.54   MEASUREMENT                                                           02/27/2018 17:49:52 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MEASUREMENT
OBJECT MODULE PLACED IN .\Objects\measurement.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Source\measurement.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\measurement.lst) TABS(2) OBJECT(.\Objects\measurement.obj)

line level    source

   1          #include "config.h"
   2          #include "measurement.h"
   3          
   4          #ifndef ADCUC841_H
              #define ADCUC841_H
              #include <ADUC841.H>
              #endif
   8          
   9          
  10          
  11          extern volatile uint8 mode;
  12          
  13          // misc variables
  14          #ifdef USE_CIRCULAR_BUFFER
  15          #define BUFSIZE 16
  16          volatile uint16 circular_buffer[BUFSIZE] ={0}; // array to hold values
  17          #else
              volatile uint16 block_buffer =0;                // simple value to store sum
              #define DC_AVG_NUM_SAMPLES BUFSIZE*4            // can afford to take more samples if block averaging
              
              #endif
  22          uint8 buff_index_counter =0;    //indexing variable for doing running sums/filtering
  23          
  24          
  25          
  26          
  27          //dc averaging variables
  28          #define DC_TIMER_OVERFLOWS 8    // n*5.9 milliseconds between readings. NOTE: must be a power of 2
  29          #define DC_TIMER_INCREMENT 256/DC_TIMER_OVERFLOWS
  30          uint16 dc_sum;
  31          volatile uint16 dc_avg;   // value to be displayed, stored as 12bit number, convert to volts before display
  32          
  33          
  34          // rms measurement variables
  35          #define RMS_TIMER_OVERFLOWS 8   // n*5.9 milliseconds between readings. NOTE: must be a power of 2
  36          #define RMS_TIMER_INCREMENT 256/RMS_TIMER_OVERFLOWS
  37          #define RMS_MEASUREMENT_NUM_SAMPLES 128   //number of samples taken before reporting result
  38          uint32 rms_sum;   //sum needs to be 32bit since sum is of squared readings
  39          volatile uint16 rms_avg;
  40          
  41          //p2p measurement variables
  42          
  43          volatile uint16 p2p_value;
  44          
  45          
  46          
  47          //freq measurement variables
  48          extern volatile uint32 avg_freq;
  49          extern volatile uint8 nb_overflow;
  50          
  51          
  52          
  53          
  54          void setup_timers_dc_averaging(){
C51 COMPILER V9.54   MEASUREMENT                                                           02/27/2018 17:49:52 PAGE 2   

  55   1          
  56   1          T2CON = 7;  // all zero except run control
  57   1          ET2   = 1;     // enable timer 2 interrupt
  58   1          EA = 1;
  59   1        
  60   1        //disable other timers...
  61   1      
  62   1      }
  63            
  64          void setup_timers_rms_measurment(){   //same as dc averaging...
  65   1          T2CON = 7;  // all zero except run control
  66   1          ET2   = 1;     // enable timer 2 interrupt
  67   1          EA = 1;
  68   1      } 
  69          
  70          void setup_timers_freq_period_counting() {
  71   1          // Set up timer 2 in timer mode (bit1), capture mode(bit0), external control activated(bit3), timer run(
             -bit2), serial not needed(bit4-5),then interrupt modified by hardware
  72   1      //    T2CON = #00001101b;  // all zero except run control
  73   1          T2CON = 13;  // all zero except run control
  74   1          ET2   = 1;     // enable timer 2 interrupt
  75   1          EA = 1;       // enable general interrupt
  76   1        
  77   1          //uint8 nb_t2_of =0;
  78   1        
  79   1        
  80   1        //disable other timers...
  81   1        
  82   1      }
  83          
  84          
  85          
  86          
  87          
  88          
  89          void dc_voltage_measurment(){ // functions to store measurements as required
  90   1        
  91   1        static uint8 dc_voltage_num_timer_overflows=0; //counter for the number of timer overflows
  92   1        
  93   1        if (TF2 == 1){  //if counter overflow, increment counter
  94   2          // todo make the overflow happen in hardware
  95   2        dc_voltage_num_timer_overflows = dc_voltage_num_timer_overflows+DC_TIMER_INCREMENT;  // increment chosen 
             -to cause hardware overflow
  96   2        TF2 = 0;
  97   2      
  98   2          if(dc_voltage_num_timer_overflows ==0){ 
  99   3            
 100   3            uint16 val = read_analog_input_pin();
 101   3            
 102   3          #ifdef USE_CIRCULAR_BUFFER    // will update avg every time a value is read
 103   3            
 104   3            //circular buffer implementation
 105   3            
 106   3            buff_index_counter = (buff_index_counter + 1) % BUFSIZE;
 107   3            dc_sum = dc_sum - circular_buffer[buff_index_counter];        //subtract the old value from the running sum
 108   3            circular_buffer[buff_index_counter] = val;
 109   3            dc_sum = dc_sum + circular_buffer[buff_index_counter];        //add new value to sum
 110   3            dc_avg = dc_sum/BUFSIZE;
 111   3            
 112   3            
 113   3            
 114   3          #else                         // update avg every after DC_AVG_NUM_SAMPLES readings
C51 COMPILER V9.54   MEASUREMENT                                                           02/27/2018 17:49:52 PAGE 3   

                    
                    //block buffer implementation 
                    
                    buff_index_counter = (buff_index_counter + 1) % DC_AVG_NUM_SAMPLES;
                    dc_sum = dc_sum+val;
                    if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, calcualte avg and reset sum
                      dc_avg= dc_sum/DC_AVG_NUM_SAMPLES;
                      dc_sum=0; 
                    }
              
                    
                  #endif
 127   3            
 128   3          }
 129   2        }
 130   1        
 131   1        else if(EXF2==1)    //if the pin input triggered interrupt, reset
 132   1          EXF2 =0;
 133   1      } 
 134          
 135          void rms_measurment(){
 136   1      
 137   1        static uint8 rms_measurement_num_timer_overflows=0;
 138   1        
 139   1        if (TF2 == 1){  //if counter overflow, increment counter
 140   2          
 141   2          rms_measurement_num_timer_overflows = rms_measurement_num_timer_overflows+RMS_TIMER_INCREMENT;
 142   2          
 143   2          TF2 = 0;
 144   2      
 145   2            if(rms_measurement_num_timer_overflows ==0){  
 146   3              
 147   3              uint16 val = read_analog_input_pin();
 148   3              
 149   3              buff_index_counter = (buff_index_counter + 1) % RMS_MEASUREMENT_NUM_SAMPLES;
 150   3              rms_sum = rms_sum+(val*val);    //running sum of squared readings
 151   3              
 152   3              if (buff_index_counter==0){ //after DC_AVG_NUM_SAMPLES readings, calculate rms and reset sum
 153   4                rms_avg = my_sqrt((rms_sum/RMS_MEASUREMENT_NUM_SAMPLES));
 154   4                rms_sum=0;
 155   4              }
 156   3            }
 157   2          }
 158   1      
 159   1        else if(EXF2==1)    
 160   1          EXF2 =0;
 161   1      }         
 162          
 163          void p2p_measurement(){}      
 164          
 165          void frequency_measurement() {
 166   1        //Setup the initial values of the static variables to ZERO
 167   1        static uint32 new_sample=0;
 168   1        static uint16 old_sample=0;
 169   1        
 170   1        
 171   1        if(EXF2==1){ // new edges incoming (of the periodic signal we want to measure) => end of the a period
 172   2          //What is the new sample ?
 173   2          
 174   2          new_sample = ((uint32)nb_overflow<<16)  | ((uint32)RCAP2H<<8) | ((uint32)RCAP2L); //concatenate the 3 byt
             -es
 175   2          new_sample -=old_sample;
C51 COMPILER V9.54   MEASUREMENT                                                           02/27/2018 17:49:52 PAGE 4   

 176   2          
 177   2          //Update the average using IIR filter
 178   2          avg_freq=(new_sample*3)/20 + (avg_freq*17)/20;   //alpha chosen 0.15=3/20
 179   2          
 180   2          //Prepare the next interruption
 181   2          old_sample= ((uint16)RCAP2H)<<8 | ((uint16)RCAP2L);
 182   2      
 183   2          nb_overflow=0;
 184   2          EXF2=0;//clear the flag
 185   2        }
 186   1          else  //EXF2==0 and TF2==1
 187   1        {
 188   2            nb_overflow++;
 189   2            TF2=0; //clear the flag
 190   2        } 
 191   1        
 192   1      }
 193            
 194          uint16 read_analog_input_pin(){
 195   1      //CS0 = 0;  //confirm analog pin
 196   1      //CS1 = 1;
 197   1      //CS2 = 0;
 198   1      //CS3 = 0;
 199   1      uint8 val_LSB = ADCDATAL;
 200   1      uint8 val_MSB = ADCDATAH;
 201   1      uint16 val = (val_MSB>>8)+val_LSB;
 202   1        return val;
 203   1      } 
 204          
 205          
 206          /*------------------------------------------------
 207          Interrupt service routine for timer 2 interrupt.
 208          Called by the hardware when the interrupt occurs.
 209          ------------------------------------------------*/
 210          void timer2 (void) interrupt 5   // interrupt vector at 002BH
 211          {
 212   1        // time effiency requires bitwise operation with if/else statements
 213   1        switch(mode){
 214   2          case 0:   dc_voltage_measurment();  break;
 215   2          case 1:   rms_measurment();         break;
 216   2          case 2:   p2p_measurement();        break;
 217   2          case 3:   frequency_measurement();  break;
 218   2        }   
 219   1        
 220   1      } // end timer2 interrupt service routine
 221          
 222          uint8 analog_reading_to_voltage(uint16 value){
 223   1        return ((value*VOLTAGE_RANGE)/4096);
 224   1      }
 225          
 226          uint8 my_sqrt(uint16 squared_val){
 227   1        
 228   1        /* method:
 229   1        sum odd numbers up to squared_val
 230   1        number of values used in sum is root
 231   1        
 232   1        1+3 = 4         -> 2 values in sum, 2 is root of 4
 233   1        1+3+5 = 9       -> 3 is root 9
 234   1        1+3+5+7 = 16    -> 4 is root 16
 235   1        1+3+5+7+9 = 25  -> 5 is root 25
 236   1        ...
 237   1        
C51 COMPILER V9.54   MEASUREMENT                                                           02/27/2018 17:49:52 PAGE 5   

 238   1        this method should be fast since no multiplication required
 239   1        Note: will return the root rounded up to nearest value 
 240   1        -> my_sqrt(2), my_sqrt(3), my_sqrt(4) will all return 2
 241   1        
 242   1        */
 243   1        
 244   1        uint8 i;    //odd numbers to be added to sum
 245   1        uint16 x=0;   //running total
 246   1        uint8 count=0;
 247   1        for(i=1;x<=squared_val;i+=2)
 248   1              {
 249   2                  x = x + i;
 250   2                  count++;
 251   2      
 252   2              }
 253   1        return count;
 254   1      }
 255          
 256          
 257           
 258          
 259          
 260          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    465    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     49       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
